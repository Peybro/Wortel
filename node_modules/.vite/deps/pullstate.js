import {
  require_react
} from "./chunk-SRNGOEPD.js";
import {
  __commonJS,
  __toESM
} from "./chunk-NISBT54A.js";

// node_modules/fast-deep-equal/es6/index.js
var require_es6 = __commonJS({
  "node_modules/fast-deep-equal/es6/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a2, b2) {
      if (a2 === b2)
        return true;
      if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
        if (a2.constructor !== b2.constructor)
          return false;
        var length, i2, keys;
        if (Array.isArray(a2)) {
          length = a2.length;
          if (length != b2.length)
            return false;
          for (i2 = length; i2-- !== 0; )
            if (!equal(a2[i2], b2[i2]))
              return false;
          return true;
        }
        if (a2 instanceof Map && b2 instanceof Map) {
          if (a2.size !== b2.size)
            return false;
          for (i2 of a2.entries())
            if (!b2.has(i2[0]))
              return false;
          for (i2 of a2.entries())
            if (!equal(i2[1], b2.get(i2[0])))
              return false;
          return true;
        }
        if (a2 instanceof Set && b2 instanceof Set) {
          if (a2.size !== b2.size)
            return false;
          for (i2 of a2.entries())
            if (!b2.has(i2[0]))
              return false;
          return true;
        }
        if (ArrayBuffer.isView(a2) && ArrayBuffer.isView(b2)) {
          length = a2.length;
          if (length != b2.length)
            return false;
          for (i2 = length; i2-- !== 0; )
            if (a2[i2] !== b2[i2])
              return false;
          return true;
        }
        if (a2.constructor === RegExp)
          return a2.source === b2.source && a2.flags === b2.flags;
        if (a2.valueOf !== Object.prototype.valueOf)
          return a2.valueOf() === b2.valueOf();
        if (a2.toString !== Object.prototype.toString)
          return a2.toString() === b2.toString();
        keys = Object.keys(a2);
        length = keys.length;
        if (length !== Object.keys(b2).length)
          return false;
        for (i2 = length; i2-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b2, keys[i2]))
            return false;
        for (i2 = length; i2-- !== 0; ) {
          var key = keys[i2];
          if (!equal(a2[key], b2[key]))
            return false;
        }
        return true;
      }
      return a2 !== a2 && b2 !== b2;
    };
  }
});

// node_modules/pullstate/dist/index.es.js
var import_es6 = __toESM(require_es6());
var import_react = __toESM(require_react());

// node_modules/immer/dist/immer.esm.js
function n(n2) {
  for (var r2 = arguments.length, t2 = Array(r2 > 1 ? r2 - 1 : 0), e = 1; e < r2; e++)
    t2[e - 1] = arguments[e];
  if (true) {
    var i2 = Y[n2], o2 = i2 ? typeof i2 == "function" ? i2.apply(null, t2) : i2 : "unknown error nr: " + n2;
    throw Error("[Immer] " + o2);
  }
  throw Error("[Immer] minified error nr: " + n2 + (t2.length ? " " + t2.map(function(n3) {
    return "'" + n3 + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function r(n2) {
  return !!n2 && !!n2[Q];
}
function t(n2) {
  return !!n2 && (function(n3) {
    if (!n3 || typeof n3 != "object")
      return false;
    var r2 = Object.getPrototypeOf(n3);
    if (r2 === null)
      return true;
    var t2 = Object.hasOwnProperty.call(r2, "constructor") && r2.constructor;
    return t2 === Object || typeof t2 == "function" && Function.toString.call(t2) === Z;
  }(n2) || Array.isArray(n2) || !!n2[L] || !!n2.constructor[L] || s(n2) || v(n2));
}
function i(n2, r2, t2) {
  t2 === void 0 && (t2 = false), o(n2) === 0 ? (t2 ? Object.keys : nn)(n2).forEach(function(e) {
    t2 && typeof e == "symbol" || r2(e, n2[e], n2);
  }) : n2.forEach(function(t3, e) {
    return r2(e, t3, n2);
  });
}
function o(n2) {
  var r2 = n2[Q];
  return r2 ? r2.i > 3 ? r2.i - 4 : r2.i : Array.isArray(n2) ? 1 : s(n2) ? 2 : v(n2) ? 3 : 0;
}
function u(n2, r2) {
  return o(n2) === 2 ? n2.has(r2) : Object.prototype.hasOwnProperty.call(n2, r2);
}
function a(n2, r2) {
  return o(n2) === 2 ? n2.get(r2) : n2[r2];
}
function f(n2, r2, t2) {
  var e = o(n2);
  e === 2 ? n2.set(r2, t2) : e === 3 ? (n2.delete(r2), n2.add(t2)) : n2[r2] = t2;
}
function c(n2, r2) {
  return n2 === r2 ? n2 !== 0 || 1 / n2 == 1 / r2 : n2 != n2 && r2 != r2;
}
function s(n2) {
  return X && n2 instanceof Map;
}
function v(n2) {
  return q && n2 instanceof Set;
}
function p(n2) {
  return n2.o || n2.t;
}
function l(n2) {
  if (Array.isArray(n2))
    return Array.prototype.slice.call(n2);
  var r2 = rn(n2);
  delete r2[Q];
  for (var t2 = nn(r2), e = 0; e < t2.length; e++) {
    var i2 = t2[e], o2 = r2[i2];
    o2.writable === false && (o2.writable = true, o2.configurable = true), (o2.get || o2.set) && (r2[i2] = { configurable: true, writable: true, enumerable: o2.enumerable, value: n2[i2] });
  }
  return Object.create(Object.getPrototypeOf(n2), r2);
}
function d(n2, e) {
  return e === void 0 && (e = false), y(n2) || r(n2) || !t(n2) ? n2 : (o(n2) > 1 && (n2.set = n2.add = n2.clear = n2.delete = h), Object.freeze(n2), e && i(n2, function(n3, r2) {
    return d(r2, true);
  }, true), n2);
}
function h() {
  n(2);
}
function y(n2) {
  return n2 == null || typeof n2 != "object" || Object.isFrozen(n2);
}
function b(r2) {
  var t2 = tn[r2];
  return t2 || n(18, r2), t2;
}
function m(n2, r2) {
  tn[n2] || (tn[n2] = r2);
}
function _() {
  return U || n(0), U;
}
function j(n2, r2) {
  r2 && (b("Patches"), n2.u = [], n2.s = [], n2.v = r2);
}
function O(n2) {
  g(n2), n2.p.forEach(S), n2.p = null;
}
function g(n2) {
  n2 === U && (U = n2.l);
}
function w(n2) {
  return U = { p: [], l: U, h: n2, m: true, _: 0 };
}
function S(n2) {
  var r2 = n2[Q];
  r2.i === 0 || r2.i === 1 ? r2.j() : r2.O = true;
}
function P(r2, e) {
  e._ = e.p.length;
  var i2 = e.p[0], o2 = r2 !== void 0 && r2 !== i2;
  return e.h.g || b("ES5").S(e, r2, o2), o2 ? (i2[Q].P && (O(e), n(4)), t(r2) && (r2 = M(e, r2), e.l || x(e, r2)), e.u && b("Patches").M(i2[Q].t, r2, e.u, e.s)) : r2 = M(e, i2, []), O(e), e.u && e.v(e.u, e.s), r2 !== H ? r2 : void 0;
}
function M(n2, r2, t2) {
  if (y(r2))
    return r2;
  var e = r2[Q];
  if (!e)
    return i(r2, function(i2, o3) {
      return A(n2, e, r2, i2, o3, t2);
    }, true), r2;
  if (e.A !== n2)
    return r2;
  if (!e.P)
    return x(n2, e.t, true), e.t;
  if (!e.I) {
    e.I = true, e.A._--;
    var o2 = e.i === 4 || e.i === 5 ? e.o = l(e.k) : e.o;
    i(e.i === 3 ? new Set(o2) : o2, function(r3, i2) {
      return A(n2, e, o2, r3, i2, t2);
    }), x(n2, o2, false), t2 && n2.u && b("Patches").R(e, t2, n2.u, n2.s);
  }
  return e.o;
}
function A(e, i2, o2, a2, c2, s2) {
  if (c2 === o2 && n(5), r(c2)) {
    var v2 = M(e, c2, s2 && i2 && i2.i !== 3 && !u(i2.D, a2) ? s2.concat(a2) : void 0);
    if (f(o2, a2, v2), !r(v2))
      return;
    e.m = false;
  }
  if (t(c2) && !y(c2)) {
    if (!e.h.F && e._ < 1)
      return;
    M(e, c2), i2 && i2.A.l || x(e, c2);
  }
}
function x(n2, r2, t2) {
  t2 === void 0 && (t2 = false), n2.h.F && n2.m && d(r2, t2);
}
function z(n2, r2) {
  var t2 = n2[Q];
  return (t2 ? p(t2) : n2)[r2];
}
function I(n2, r2) {
  if (r2 in n2)
    for (var t2 = Object.getPrototypeOf(n2); t2; ) {
      var e = Object.getOwnPropertyDescriptor(t2, r2);
      if (e)
        return e;
      t2 = Object.getPrototypeOf(t2);
    }
}
function k(n2) {
  n2.P || (n2.P = true, n2.l && k(n2.l));
}
function E(n2) {
  n2.o || (n2.o = l(n2.t));
}
function R(n2, r2, t2) {
  var e = s(r2) ? b("MapSet").N(r2, t2) : v(r2) ? b("MapSet").T(r2, t2) : n2.g ? function(n3, r3) {
    var t3 = Array.isArray(n3), e2 = { i: t3 ? 1 : 0, A: r3 ? r3.A : _(), P: false, I: false, D: {}, l: r3, t: n3, k: null, o: null, j: null, C: false }, i2 = e2, o2 = en;
    t3 && (i2 = [e2], o2 = on);
    var u2 = Proxy.revocable(i2, o2), a2 = u2.revoke, f2 = u2.proxy;
    return e2.k = f2, e2.j = a2, f2;
  }(r2, t2) : b("ES5").J(r2, t2);
  return (t2 ? t2.A : _()).p.push(e), e;
}
function D(e) {
  return r(e) || n(22, e), function n2(r2) {
    if (!t(r2))
      return r2;
    var e2, u2 = r2[Q], c2 = o(r2);
    if (u2) {
      if (!u2.P && (u2.i < 4 || !b("ES5").K(u2)))
        return u2.t;
      u2.I = true, e2 = F(r2, c2), u2.I = false;
    } else
      e2 = F(r2, c2);
    return i(e2, function(r3, t2) {
      u2 && a(u2.t, r3) === t2 || f(e2, r3, n2(t2));
    }), c2 === 3 ? new Set(e2) : e2;
  }(e);
}
function F(n2, r2) {
  switch (r2) {
    case 2:
      return new Map(n2);
    case 3:
      return Array.from(n2);
  }
  return l(n2);
}
function T() {
  function e(n2) {
    if (!t(n2))
      return n2;
    if (Array.isArray(n2))
      return n2.map(e);
    if (s(n2))
      return new Map(Array.from(n2.entries()).map(function(n3) {
        return [n3[0], e(n3[1])];
      }));
    if (v(n2))
      return new Set(Array.from(n2).map(e));
    var r2 = Object.create(Object.getPrototypeOf(n2));
    for (var i2 in n2)
      r2[i2] = e(n2[i2]);
    return u(n2, L) && (r2[L] = n2[L]), r2;
  }
  function f2(n2) {
    return r(n2) ? e(n2) : n2;
  }
  var c2 = "add";
  m("Patches", { $: function(r2, t2) {
    return t2.forEach(function(t3) {
      for (var i2 = t3.path, u2 = t3.op, f3 = r2, s2 = 0; s2 < i2.length - 1; s2++) {
        var v2 = o(f3), p2 = "" + i2[s2];
        v2 !== 0 && v2 !== 1 || p2 !== "__proto__" && p2 !== "constructor" || n(24), typeof f3 == "function" && p2 === "prototype" && n(24), typeof (f3 = a(f3, p2)) != "object" && n(15, i2.join("/"));
      }
      var l2 = o(f3), d2 = e(t3.value), h2 = i2[i2.length - 1];
      switch (u2) {
        case "replace":
          switch (l2) {
            case 2:
              return f3.set(h2, d2);
            case 3:
              n(16);
            default:
              return f3[h2] = d2;
          }
        case c2:
          switch (l2) {
            case 1:
              return h2 === "-" ? f3.push(d2) : f3.splice(h2, 0, d2);
            case 2:
              return f3.set(h2, d2);
            case 3:
              return f3.add(d2);
            default:
              return f3[h2] = d2;
          }
        case "remove":
          switch (l2) {
            case 1:
              return f3.splice(h2, 1);
            case 2:
              return f3.delete(h2);
            case 3:
              return f3.delete(t3.value);
            default:
              return delete f3[h2];
          }
        default:
          n(17, u2);
      }
    }), r2;
  }, R: function(n2, r2, t2, e2) {
    switch (n2.i) {
      case 0:
      case 4:
      case 2:
        return function(n3, r3, t3, e3) {
          var o2 = n3.t, s2 = n3.o;
          i(n3.D, function(n4, i2) {
            var v2 = a(o2, n4), p2 = a(s2, n4), l2 = i2 ? u(o2, n4) ? "replace" : c2 : "remove";
            if (v2 !== p2 || l2 !== "replace") {
              var d2 = r3.concat(n4);
              t3.push(l2 === "remove" ? { op: l2, path: d2 } : { op: l2, path: d2, value: p2 }), e3.push(l2 === c2 ? { op: "remove", path: d2 } : l2 === "remove" ? { op: c2, path: d2, value: f2(v2) } : { op: "replace", path: d2, value: f2(v2) });
            }
          });
        }(n2, r2, t2, e2);
      case 5:
      case 1:
        return function(n3, r3, t3, e3) {
          var i2 = n3.t, o2 = n3.D, u2 = n3.o;
          if (u2.length < i2.length) {
            var a2 = [u2, i2];
            i2 = a2[0], u2 = a2[1];
            var s2 = [e3, t3];
            t3 = s2[0], e3 = s2[1];
          }
          for (var v2 = 0; v2 < i2.length; v2++)
            if (o2[v2] && u2[v2] !== i2[v2]) {
              var p2 = r3.concat([v2]);
              t3.push({ op: "replace", path: p2, value: f2(u2[v2]) }), e3.push({ op: "replace", path: p2, value: f2(i2[v2]) });
            }
          for (var l2 = i2.length; l2 < u2.length; l2++) {
            var d2 = r3.concat([l2]);
            t3.push({ op: c2, path: d2, value: f2(u2[l2]) });
          }
          i2.length < u2.length && e3.push({ op: "replace", path: r3.concat(["length"]), value: i2.length });
        }(n2, r2, t2, e2);
      case 3:
        return function(n3, r3, t3, e3) {
          var i2 = n3.t, o2 = n3.o, u2 = 0;
          i2.forEach(function(n4) {
            if (!o2.has(n4)) {
              var i3 = r3.concat([u2]);
              t3.push({ op: "remove", path: i3, value: n4 }), e3.unshift({ op: c2, path: i3, value: n4 });
            }
            u2++;
          }), u2 = 0, o2.forEach(function(n4) {
            if (!i2.has(n4)) {
              var o3 = r3.concat([u2]);
              t3.push({ op: c2, path: o3, value: n4 }), e3.unshift({ op: "remove", path: o3, value: n4 });
            }
            u2++;
          });
        }(n2, r2, t2, e2);
    }
  }, M: function(n2, r2, t2, e2) {
    t2.push({ op: "replace", path: [], value: r2 === H ? void 0 : r2 }), e2.push({ op: "replace", path: [], value: n2 });
  } });
}
var G;
var U;
var W = typeof Symbol != "undefined" && typeof Symbol("x") == "symbol";
var X = typeof Map != "undefined";
var q = typeof Set != "undefined";
var B = typeof Proxy != "undefined" && Proxy.revocable !== void 0 && typeof Reflect != "undefined";
var H = W ? Symbol.for("immer-nothing") : ((G = {})["immer-nothing"] = true, G);
var L = W ? Symbol.for("immer-draftable") : "__$immer_draftable";
var Q = W ? Symbol.for("immer-state") : "__$immer_state";
var Y = { 0: "Illegal state", 1: "Immer drafts cannot have computed properties", 2: "This object has been frozen and should not be mutated", 3: function(n2) {
  return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + n2;
}, 4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", 5: "Immer forbids circular references", 6: "The first or second argument to `produce` must be a function", 7: "The third argument to `produce` must be a function or undefined", 8: "First argument to `createDraft` must be a plain object, an array, or an immerable object", 9: "First argument to `finishDraft` must be a draft returned by `createDraft`", 10: "The given draft is already finalized", 11: "Object.defineProperty() cannot be used on an Immer draft", 12: "Object.setPrototypeOf() cannot be used on an Immer draft", 13: "Immer only supports deleting array indices", 14: "Immer only supports setting array indices and the 'length' property", 15: function(n2) {
  return "Cannot apply patch, path doesn't resolve: " + n2;
}, 16: 'Sets cannot have "replace" patches.', 17: function(n2) {
  return "Unsupported patch operation: " + n2;
}, 18: function(n2) {
  return "The plugin for '" + n2 + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + n2 + "()` when initializing your application.";
}, 20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available", 21: function(n2) {
  return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + n2 + "'";
}, 22: function(n2) {
  return "'current' expects a draft, got: " + n2;
}, 23: function(n2) {
  return "'original' expects a draft, got: " + n2;
}, 24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed" };
var Z = "" + Object.prototype.constructor;
var nn = typeof Reflect != "undefined" && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols !== void 0 ? function(n2) {
  return Object.getOwnPropertyNames(n2).concat(Object.getOwnPropertySymbols(n2));
} : Object.getOwnPropertyNames;
var rn = Object.getOwnPropertyDescriptors || function(n2) {
  var r2 = {};
  return nn(n2).forEach(function(t2) {
    r2[t2] = Object.getOwnPropertyDescriptor(n2, t2);
  }), r2;
};
var tn = {};
var en = { get: function(n2, r2) {
  if (r2 === Q)
    return n2;
  var e = p(n2);
  if (!u(e, r2))
    return function(n3, r3, t2) {
      var e2, i3 = I(r3, t2);
      return i3 ? "value" in i3 ? i3.value : (e2 = i3.get) === null || e2 === void 0 ? void 0 : e2.call(n3.k) : void 0;
    }(n2, e, r2);
  var i2 = e[r2];
  return n2.I || !t(i2) ? i2 : i2 === z(n2.t, r2) ? (E(n2), n2.o[r2] = R(n2.A.h, i2, n2)) : i2;
}, has: function(n2, r2) {
  return r2 in p(n2);
}, ownKeys: function(n2) {
  return Reflect.ownKeys(p(n2));
}, set: function(n2, r2, t2) {
  var e = I(p(n2), r2);
  if (e == null ? void 0 : e.set)
    return e.set.call(n2.k, t2), true;
  if (!n2.P) {
    var i2 = z(p(n2), r2), o2 = i2 == null ? void 0 : i2[Q];
    if (o2 && o2.t === t2)
      return n2.o[r2] = t2, n2.D[r2] = false, true;
    if (c(t2, i2) && (t2 !== void 0 || u(n2.t, r2)))
      return true;
    E(n2), k(n2);
  }
  return n2.o[r2] === t2 && typeof t2 != "number" && (t2 !== void 0 || r2 in n2.o) || (n2.o[r2] = t2, n2.D[r2] = true, true);
}, deleteProperty: function(n2, r2) {
  return z(n2.t, r2) !== void 0 || r2 in n2.t ? (n2.D[r2] = false, E(n2), k(n2)) : delete n2.D[r2], n2.o && delete n2.o[r2], true;
}, getOwnPropertyDescriptor: function(n2, r2) {
  var t2 = p(n2), e = Reflect.getOwnPropertyDescriptor(t2, r2);
  return e ? { writable: true, configurable: n2.i !== 1 || r2 !== "length", enumerable: e.enumerable, value: t2[r2] } : e;
}, defineProperty: function() {
  n(11);
}, getPrototypeOf: function(n2) {
  return Object.getPrototypeOf(n2.t);
}, setPrototypeOf: function() {
  n(12);
} };
var on = {};
i(en, function(n2, r2) {
  on[n2] = function() {
    return arguments[0] = arguments[0][0], r2.apply(this, arguments);
  };
}), on.deleteProperty = function(r2, t2) {
  return isNaN(parseInt(t2)) && n(13), on.set.call(this, r2, t2, void 0);
}, on.set = function(r2, t2, e) {
  return t2 !== "length" && isNaN(parseInt(t2)) && n(14), en.set.call(this, r2[0], t2, e, r2[0]);
};
var un = function() {
  function e(r2) {
    var e2 = this;
    this.g = B, this.F = true, this.produce = function(r3, i3, o2) {
      if (typeof r3 == "function" && typeof i3 != "function") {
        var u2 = i3;
        i3 = r3;
        var a2 = e2;
        return function(n2) {
          var r4 = this;
          n2 === void 0 && (n2 = u2);
          for (var t2 = arguments.length, e3 = Array(t2 > 1 ? t2 - 1 : 0), o3 = 1; o3 < t2; o3++)
            e3[o3 - 1] = arguments[o3];
          return a2.produce(n2, function(n3) {
            var t3;
            return (t3 = i3).call.apply(t3, [r4, n3].concat(e3));
          });
        };
      }
      var f2;
      if (typeof i3 != "function" && n(6), o2 !== void 0 && typeof o2 != "function" && n(7), t(r3)) {
        var c2 = w(e2), s2 = R(e2, r3, void 0), v2 = true;
        try {
          f2 = i3(s2), v2 = false;
        } finally {
          v2 ? O(c2) : g(c2);
        }
        return typeof Promise != "undefined" && f2 instanceof Promise ? f2.then(function(n2) {
          return j(c2, o2), P(n2, c2);
        }, function(n2) {
          throw O(c2), n2;
        }) : (j(c2, o2), P(f2, c2));
      }
      if (!r3 || typeof r3 != "object") {
        if ((f2 = i3(r3)) === void 0 && (f2 = r3), f2 === H && (f2 = void 0), e2.F && d(f2, true), o2) {
          var p2 = [], l2 = [];
          b("Patches").M(r3, f2, p2, l2), o2(p2, l2);
        }
        return f2;
      }
      n(21, r3);
    }, this.produceWithPatches = function(n2, r3) {
      if (typeof n2 == "function")
        return function(r4) {
          for (var t3 = arguments.length, i4 = Array(t3 > 1 ? t3 - 1 : 0), o3 = 1; o3 < t3; o3++)
            i4[o3 - 1] = arguments[o3];
          return e2.produceWithPatches(r4, function(r5) {
            return n2.apply(void 0, [r5].concat(i4));
          });
        };
      var t2, i3, o2 = e2.produce(n2, r3, function(n3, r4) {
        t2 = n3, i3 = r4;
      });
      return typeof Promise != "undefined" && o2 instanceof Promise ? o2.then(function(n3) {
        return [n3, t2, i3];
      }) : [o2, t2, i3];
    }, typeof (r2 == null ? void 0 : r2.useProxies) == "boolean" && this.setUseProxies(r2.useProxies), typeof (r2 == null ? void 0 : r2.autoFreeze) == "boolean" && this.setAutoFreeze(r2.autoFreeze);
  }
  var i2 = e.prototype;
  return i2.createDraft = function(e2) {
    t(e2) || n(8), r(e2) && (e2 = D(e2));
    var i3 = w(this), o2 = R(this, e2, void 0);
    return o2[Q].C = true, g(i3), o2;
  }, i2.finishDraft = function(r2, t2) {
    var e2 = r2 && r2[Q];
    e2 && e2.C || n(9), e2.I && n(10);
    var i3 = e2.A;
    return j(i3, t2), P(void 0, i3);
  }, i2.setAutoFreeze = function(n2) {
    this.F = n2;
  }, i2.setUseProxies = function(r2) {
    r2 && !B && n(20), this.g = r2;
  }, i2.applyPatches = function(n2, t2) {
    var e2;
    for (e2 = t2.length - 1; e2 >= 0; e2--) {
      var i3 = t2[e2];
      if (i3.path.length === 0 && i3.op === "replace") {
        n2 = i3.value;
        break;
      }
    }
    e2 > -1 && (t2 = t2.slice(e2 + 1));
    var o2 = b("Patches").$;
    return r(n2) ? o2(n2, t2) : this.produce(n2, function(n3) {
      return o2(n3, t2);
    });
  }, e;
}();
var an = new un();
var fn = an.produce;
var cn = an.produceWithPatches.bind(an);
var sn = an.setAutoFreeze.bind(an);
var vn = an.setUseProxies.bind(an);
var pn = an.applyPatches.bind(an);
var ln = an.createDraft.bind(an);
var dn = an.finishDraft.bind(an);
var immer_esm_default = fn;

// node_modules/pullstate/dist/index.es.js
function useStoreState(store, getSubState, deps) {
  const updateRef = (0, import_react.useRef)({ state: void 0, initialized: false });
  if (!updateRef.current.initialized) {
    updateRef.current.state = getSubState ? getSubState(store.getRawState()) : store.getRawState();
    updateRef.current.initialized = true;
  }
  const [, setUpdateTrigger] = (0, import_react.useState)(0);
  (0, import_react.useEffect)(() => {
    const effectState = { shouldUpdate: true };
    function update2() {
      if (effectState.shouldUpdate) {
        const nextSubState = getSubState ? getSubState(store.getRawState()) : store.getRawState();
        if (!(0, import_es6.default)(updateRef.current.state, nextSubState)) {
          if (effectState.shouldUpdate) {
            updateRef.current.state = nextSubState;
            setUpdateTrigger((val) => val + 1);
          }
        }
      }
    }
    store._addUpdateListener(update2);
    update2();
    return () => {
      effectState.shouldUpdate = false;
      store._removeUpdateListener(update2);
    };
  }, deps !== null && deps !== void 0 ? deps : []);
  if (deps !== void 0) {
    const prevDeps = (0, import_react.useRef)(deps);
    if (!(0, import_es6.default)(deps, prevDeps)) {
      updateRef.current.state = getSubState(store.getRawState());
    }
  }
  return updateRef.current.state;
}
var updateListenerOrd = 0;
function fastGet(obj, path) {
  return path.reduce((cur = obj, key) => {
    return cur[key];
  }, void 0);
}
function getSubStateFromPaths(store, paths) {
  const state = store.getRawState();
  const resp = [];
  for (const path of paths) {
    resp.push(fastGet(state, path));
  }
  return resp;
}
function useStoreStateOpt(store, paths) {
  const [subState, setSubState] = (0, import_react.useState)(() => getSubStateFromPaths(store, paths));
  const updateRef = (0, import_react.useRef)({
    shouldUpdate: true,
    onStoreUpdate: null,
    currentSubState: null,
    ordKey: `_${updateListenerOrd++}`
  });
  updateRef.current.currentSubState = subState;
  if (updateRef.current.onStoreUpdate === null) {
    updateRef.current.onStoreUpdate = function onStoreUpdateOpt() {
      if (updateRef.current.shouldUpdate) {
        setSubState(getSubStateFromPaths(store, paths));
      }
    };
    store._addUpdateListenerOpt(updateRef.current.onStoreUpdate, updateRef.current.ordKey, paths);
  }
  (0, import_react.useEffect)(() => () => {
    updateRef.current.shouldUpdate = false;
    store._removeUpdateListenerOpt(updateRef.current.ordKey);
  }, []);
  return subState;
}
function useLocalStore(initialState, deps) {
  const storeRef = (0, import_react.useRef)();
  if (storeRef.current == null) {
    storeRef.current = new Store(initialState);
  }
  if (deps !== void 0) {
    const prevDeps = (0, import_react.useRef)(deps);
    if (!(0, import_es6.default)(deps, prevDeps)) {
      storeRef.current = new Store(initialState);
    }
  }
  return storeRef.current;
}
var globalClientState = {
  storeOrdinal: 0,
  batching: false,
  flushStores: {}
};
T();
function makeSubscriptionFunction(store, watch, listener) {
  let lastWatchState = watch(store.getRawState());
  return () => {
    const currentState = store.getRawState();
    const nextWatchState = watch(currentState);
    if (!(0, import_es6.default)(nextWatchState, lastWatchState)) {
      listener(nextWatchState, currentState, lastWatchState);
      lastWatchState = nextWatchState;
    }
  };
}
function makeReactionFunctionCreator(watch, reaction) {
  return (store) => {
    let lastWatchState = watch(store.getRawState());
    return (forceRun = false) => {
      const currentState = store.getRawState();
      const nextWatchState = watch(currentState);
      if (forceRun || !(0, import_es6.default)(nextWatchState, lastWatchState)) {
        if (store._optListenerCount > 0) {
          const [nextState, patches, inversePatches] = cn(currentState, (s2) => reaction(nextWatchState, s2, currentState, lastWatchState));
          store._updateStateWithoutReaction(nextState);
          lastWatchState = nextWatchState;
          if (patches.length > 0) {
            store._patchListeners.forEach((listener) => listener(patches, inversePatches));
            return Object.keys(getChangedPathsFromPatches(patches));
          }
        } else {
          if (store._patchListeners.length > 0) {
            const [nextState, patches, inversePatches] = cn(currentState, (s2) => reaction(nextWatchState, s2, currentState, lastWatchState));
            if (patches.length > 0) {
              store._patchListeners.forEach((listener) => listener(patches, inversePatches));
            }
            store._updateStateWithoutReaction(nextState);
          } else {
            store._updateStateWithoutReaction(fn(currentState, (s2) => reaction(nextWatchState, s2, currentState, lastWatchState)));
          }
          lastWatchState = nextWatchState;
        }
      }
      return [];
    };
  };
}
var optPathDivider = "~._.~";
var Store = class {
  constructor(initialState) {
    this.updateListeners = [];
    this.ssr = false;
    this.reactions = [];
    this.clientSubscriptions = [];
    this.reactionCreators = [];
    this.optimizedUpdateListeners = {};
    this.optimizedUpdateListenerPaths = {};
    this.optimizedListenerPropertyMap = {};
    this._optListenerCount = 0;
    this._patchListeners = [];
    if (initialState instanceof Function) {
      const state = initialState();
      this.currentState = state;
      this.initialState = state;
      this.createInitialState = initialState;
    } else {
      this.currentState = initialState;
      this.initialState = initialState;
      this.createInitialState = () => initialState;
    }
    this.internalOrdId = globalClientState.storeOrdinal++;
  }
  _setInternalOptions({ ssr, reactionCreators = [] }) {
    this.ssr = ssr;
    this.reactionCreators = reactionCreators;
    this.reactions = reactionCreators.map((rc) => rc(this));
  }
  _getReactionCreators() {
    return this.reactionCreators;
  }
  _instantiateReactions() {
    this.reactions = this.reactionCreators.map((rc) => rc(this));
  }
  _getInitialState() {
    return this.createInitialState();
  }
  _updateStateWithoutReaction(nextState) {
    this.currentState = nextState;
  }
  _updateState(nextState, updateKeyedPaths = []) {
    this.currentState = nextState;
    this.batchState = void 0;
    for (const runReaction of this.reactions) {
      updateKeyedPaths.push(...runReaction());
    }
    if (!this.ssr) {
      for (const runSubscription of this.clientSubscriptions) {
        runSubscription();
      }
      if (updateKeyedPaths.length > 0) {
        const updateOrds = /* @__PURE__ */ new Set();
        for (const keyedPath of updateKeyedPaths) {
          if (this.optimizedListenerPropertyMap[keyedPath]) {
            for (const ord of this.optimizedListenerPropertyMap[keyedPath]) {
              updateOrds.add(ord);
            }
          }
        }
        for (const ord of updateOrds.values()) {
          if (this.optimizedUpdateListeners[ord]) {
            this.optimizedUpdateListeners[ord]();
          }
        }
      }
      this.updateListeners.forEach((listener) => listener());
    }
  }
  _addUpdateListener(listener) {
    this.updateListeners.push(listener);
  }
  _addUpdateListenerOpt(listener, ordKey, paths) {
    this.optimizedUpdateListeners[ordKey] = listener;
    const listenerPathsKeyed = paths.map((path) => path.join(optPathDivider));
    this.optimizedUpdateListenerPaths[ordKey] = listenerPathsKeyed;
    for (const keyedPath of listenerPathsKeyed) {
      if (this.optimizedListenerPropertyMap[keyedPath] == null) {
        this.optimizedListenerPropertyMap[keyedPath] = [ordKey];
      } else {
        this.optimizedListenerPropertyMap[keyedPath].push(ordKey);
      }
    }
    this._optListenerCount++;
  }
  _removeUpdateListener(listener) {
    this.updateListeners = this.updateListeners.filter((f2) => f2 !== listener);
  }
  _removeUpdateListenerOpt(ordKey) {
    const listenerPathsKeyed = this.optimizedUpdateListenerPaths[ordKey];
    for (const keyedPath of listenerPathsKeyed) {
      this.optimizedListenerPropertyMap[keyedPath] = this.optimizedListenerPropertyMap[keyedPath].filter((ord) => ord !== ordKey);
    }
    delete this.optimizedUpdateListenerPaths[ordKey];
    delete this.optimizedUpdateListeners[ordKey];
    this._optListenerCount--;
  }
  listenToPatches(patchListener) {
    this._patchListeners.push(patchListener);
    return () => {
      this._patchListeners = this._patchListeners.filter((f2) => f2 !== patchListener);
    };
  }
  subscribe(watch, listener) {
    if (!this.ssr) {
      const func = makeSubscriptionFunction(this, watch, listener);
      this.clientSubscriptions.push(func);
      return () => {
        this.clientSubscriptions = this.clientSubscriptions.filter((f2) => f2 !== func);
      };
    }
    return () => {
      console.warn(`Pullstate: Subscriptions made on the server side are not registered - so therefor this call to unsubscribe does nothing.`);
    };
  }
  createReaction(watch, reaction, { runNow = false, runNowWithSideEffects = false } = {}) {
    const creator = makeReactionFunctionCreator(watch, reaction);
    this.reactionCreators.push(creator);
    const func = creator(this);
    this.reactions.push(func);
    if (runNow || runNowWithSideEffects) {
      func(true);
      if (runNowWithSideEffects && !this.ssr) {
        this._updateState(this.currentState);
      }
    }
    return () => {
      this.reactions = this.reactions.filter((f2) => f2 !== func);
    };
  }
  getRawState() {
    if (this.batchState !== void 0) {
      return this.batchState;
    } else {
      return this.currentState;
    }
  }
  useState(getSubState, deps) {
    return useStoreState(this, getSubState, deps);
  }
  useLocalCopyInitial(deps) {
    return useLocalStore(this.createInitialState, deps);
  }
  useLocalCopySnapshot(deps) {
    return useLocalStore(this.currentState, deps);
  }
  flushBatch(ignoreError = false) {
    if (this.batchState !== void 0) {
      if (this.batchState !== this.currentState) {
        this._updateState(this.batchState);
      }
    } else if (!ignoreError) {
      console.error(`Pullstate: Trying to flush batch state which was never created or updated on`);
    }
    this.batchState = void 0;
  }
  update(updater, patchesCallback) {
    if (globalClientState.batching) {
      if (this.batchState === void 0) {
        this.batchState = this.currentState;
        globalClientState.flushStores[this.internalOrdId] = this;
      }
      const func = typeof updater === "function";
      const [nextState, patches, inversePatches] = runUpdates(this.batchState, updater, func);
      if (patches.length > 0 && (this._patchListeners.length > 0 || patchesCallback)) {
        if (patchesCallback) {
          patchesCallback(patches, inversePatches);
        }
        this._patchListeners.forEach((listener) => listener(patches, inversePatches));
      }
      this.batchState = nextState;
    } else {
      this.batchState = void 0;
      update(this, updater, patchesCallback);
    }
  }
  replace(newState) {
    this._updateState(newState);
  }
  applyPatches(patches) {
    applyPatchesToStore(this, patches);
  }
};
function applyPatchesToStore(store, patches) {
  const currentState = store.getRawState();
  const nextState = pn(currentState, patches);
  if (nextState !== currentState) {
    store._updateState(nextState, Object.keys(getChangedPathsFromPatches(patches)));
  }
}
function getChangedPathsFromPatches(changePatches, prev = {}) {
  for (const patch of changePatches) {
    let curKey;
    for (const p2 of patch.path) {
      if (curKey) {
        curKey = `${curKey}${optPathDivider}${p2}`;
      } else {
        curKey = p2;
      }
      prev[curKey] = 1;
    }
  }
  return prev;
}
function runUpdates(currentState, updater, func) {
  return func ? cn(currentState, (s2) => updater(s2, currentState)) : updater.reduce(([nextState, patches, inversePatches], currentValue) => {
    const resp = cn(nextState, (s2) => currentValue(s2, nextState));
    patches.push(...resp[1]);
    inversePatches.push(...resp[2]);
    return [resp[0], patches, inversePatches];
  }, [currentState, [], []]);
}
function update(store, updater, patchesCallback) {
  const currentState = store.getRawState();
  const func = typeof updater === "function";
  if (store._optListenerCount > 0) {
    const [nextState, patches, inversePatches] = runUpdates(currentState, updater, func);
    if (patches.length > 0) {
      if (patchesCallback) {
        patchesCallback(patches, inversePatches);
      }
      store._patchListeners.forEach((listener) => listener(patches, inversePatches));
      store._updateState(nextState, Object.keys(getChangedPathsFromPatches(patches)));
    }
  } else {
    let nextState;
    if (store._patchListeners.length > 0 || patchesCallback) {
      const [ns, patches, inversePatches] = runUpdates(currentState, updater, func);
      if (patches.length > 0) {
        if (patchesCallback) {
          patchesCallback(patches, inversePatches);
        }
        store._patchListeners.forEach((listener) => listener(patches, inversePatches));
      }
      nextState = ns;
    } else {
      nextState = fn(currentState, (s2) => func ? updater(s2, currentState) : updater.reduce((previousValue, currentUpdater) => {
        return fn(previousValue, (s3) => currentUpdater(s3, previousValue));
      }, currentState));
    }
    if (nextState !== currentState) {
      store._updateState(nextState);
    }
  }
}
function InjectStoreState({ store, on: on2 = (s2) => s2, children }) {
  const state = useStoreState(store, on2);
  return children(state);
}
var EAsyncEndTags;
(function(EAsyncEndTags2) {
  EAsyncEndTags2["THREW_ERROR"] = "THREW_ERROR";
  EAsyncEndTags2["RETURNED_ERROR"] = "RETURNED_ERROR";
  EAsyncEndTags2["UNFINISHED"] = "UNFINISHED";
  EAsyncEndTags2["DORMANT"] = "DORMANT";
})(EAsyncEndTags || (EAsyncEndTags = {}));
var EPostActionContext;
(function(EPostActionContext2) {
  EPostActionContext2["WATCH_HIT_CACHE"] = "WATCH_HIT_CACHE";
  EPostActionContext2["BECKON_HIT_CACHE"] = "BECKON_HIT_CACHE";
  EPostActionContext2["RUN_HIT_CACHE"] = "RUN_HIT_CACHE";
  EPostActionContext2["READ_HIT_CACHE"] = "READ_HIT_CACHE";
  EPostActionContext2["READ_RUN"] = "READ_RUN";
  EPostActionContext2["SHORT_CIRCUIT"] = "SHORT_CIRCUIT";
  EPostActionContext2["DIRECT_RUN"] = "DIRECT_RUN";
  EPostActionContext2["BECKON_RUN"] = "BECKON_RUN";
  EPostActionContext2["CACHE_UPDATE"] = "CACHE_UPDATE";
})(EPostActionContext || (EPostActionContext = {}));
var clientAsyncCache = {
  listeners: {},
  results: {},
  actions: {},
  actionOrd: {}
};
var asyncCreationOrdinal = 0;
function keyFromObject(json) {
  if (json === null) {
    return "(n)";
  }
  const typeOf = typeof json;
  if (typeOf !== "object") {
    if (typeOf === "undefined") {
      return "(u)";
    } else if (typeOf === "string") {
      return ":" + json + ";";
    } else if (typeOf === "boolean" || typeOf === "number") {
      return "(" + json + ")";
    }
  }
  let prefix = "{";
  for (const key of Object.keys(json).sort()) {
    prefix += key + keyFromObject(json[key]);
  }
  return prefix + "}";
}
function notifyListeners(key) {
  if (clientAsyncCache.listeners.hasOwnProperty(key)) {
    for (const watchId of Object.keys(clientAsyncCache.listeners[key])) {
      clientAsyncCache.listeners[key][watchId]();
    }
  }
}
function clearActionCache(key, clearPending = true, notify = true) {
  if (clearPending && clientAsyncCache.actionOrd.hasOwnProperty(key)) {
    clientAsyncCache.actionOrd[key] += 1;
  }
  delete clientAsyncCache.results[key];
  if (notify) {
    notifyListeners(key);
  }
}
function actionOrdUpdate(cache, key) {
  if (!cache.actionOrd.hasOwnProperty(key)) {
    cache.actionOrd[key] = 0;
  } else {
    cache.actionOrd[key] += 1;
  }
  return cache.actionOrd[key];
}
function successResult(payload = null, tags = [], message = "") {
  return {
    payload,
    tags,
    message,
    error: false,
    errorPayload: null
  };
}
function errorResult(tags = [], message = "", errorPayload) {
  return {
    payload: null,
    tags: [EAsyncEndTags.RETURNED_ERROR, ...tags],
    message,
    error: true,
    errorPayload
  };
}
var PullstateAsyncError = class extends Error {
  constructor(message, tags) {
    super(message);
    this.tags = tags;
  }
};
var storeErrorProxy;
try {
  storeErrorProxy = new Proxy({}, {
    get: function(obj, prop) {
      throw new Error(`Pullstate: Trying to access store (${String(prop)}) inside async actions without the correct usage or setup.
If this error occurred on the server:
* If using run(), make use of your created instance for this request: instance.runAsyncAction()
* If using read(), useWatch(), useBeckon() etc. - make sure you have properly set up your <PullstateProvider/>

If this error occurred on the client:
* Make sure you have created your "pullstateCore" object with all your stores, using createPullstateCore(), and are making use of instantiate() before rendering.`);
    }
  });
} catch {
  storeErrorProxy = {};
}
var startedButUnfinishedResult = [
  true,
  false,
  {
    message: "",
    tags: [EAsyncEndTags.UNFINISHED],
    error: true,
    payload: null,
    errorPayload: null
  },
  false,
  -1
];
function createAsyncActionDirect(action, options = {}) {
  return createAsyncAction(async (args, stores, customContext) => {
    return successResult(await action(args, stores, customContext));
  }, options);
}
function convertCustomCacheBreakHook(cacheBreakHook) {
  if (cacheBreakHook != null) {
    if (typeof cacheBreakHook === "boolean") {
      return () => cacheBreakHook;
    } else if (typeof cacheBreakHook === "number") {
      return ({ timeCached, result }) => {
        if (!result.error) {
          return Date.now() - timeCached > cacheBreakHook;
        }
        return true;
      };
    }
    return cacheBreakHook;
  }
  return void 0;
}
function createAsyncAction(action, { forceContext = false, shortCircuitHook, cacheBreakHook, postActionHook, subsetKey, actionId } = {}) {
  const ordinal = actionId != null ? `_${actionId}` : asyncCreationOrdinal++;
  const onServer = typeof window === "undefined";
  function _createKey(args, customKey) {
    if (customKey != null) {
      return `${ordinal}-c-${customKey}`;
    }
    if (subsetKey !== void 0) {
      return `${ordinal}-${keyFromObject(subsetKey(args))}`;
    }
    return `${ordinal}-${keyFromObject(args)}`;
  }
  const deferWaitingKey = `def_wait_${_createKey({})}`;
  let cacheBreakWatcher = {};
  let watchIdOrd = 0;
  const shouldUpdate = {};
  function runPostActionHook(result, args, stores, context) {
    if (postActionHook !== void 0) {
      postActionHook({ args, result, stores, context });
    }
  }
  function getCachedResult({ args, cache, cacheBreakEnabled, context, fromListener, key, postActionEnabled, stores, customCacheBreak }) {
    const useCacheBreakHook = customCacheBreak !== null && customCacheBreak !== void 0 ? customCacheBreak : cacheBreakHook;
    if (cache.results.hasOwnProperty(key)) {
      const cacheBreakLoop = cacheBreakWatcher.hasOwnProperty(key) && cacheBreakWatcher[key] > 2;
      if (!onServer && !fromListener && cacheBreakEnabled && useCacheBreakHook != null && cache.results[key][1] && useCacheBreakHook({
        args,
        result: cache.results[key][2],
        stores,
        timeCached: cache.results[key][4]
      }) && !cacheBreakLoop) {
        if (cacheBreakWatcher.hasOwnProperty(key)) {
          cacheBreakWatcher[key]++;
        } else {
          cacheBreakWatcher[key] = 1;
        }
        const previous = cache.results[key];
        delete cache.results[key];
        return { cacheBroke: true, response: void 0, previous };
      } else {
        if (cacheBreakLoop) {
          console.error(`[${key}] Pullstate detected an infinite loop caused by cacheBreakHook()
returning true too often (breaking cache as soon as your action is resolving - hence
causing beckoned actions to run the action again) in one of your AsyncActions - Pullstate prevented
further looping. Fix in your cacheBreakHook() is needed.`);
        } else {
          cacheBreakWatcher[key] = 0;
        }
        if (postActionEnabled && cache.results[key][1] && !fromListener) {
          runPostActionHook(cache.results[key][2], args, stores, context);
        }
        return {
          response: cache.results[key],
          cacheBroke: false,
          previous: void 0
        };
      }
    }
    return { cacheBroke: false, response: void 0, previous: void 0 };
  }
  function createInternalAction(key, cache, args, stores, currentActionOrd, postActionEnabled, executionContext, customContext) {
    return () => action(args, stores, customContext).then((resp) => {
      if (currentActionOrd === cache.actionOrd[key]) {
        if (postActionEnabled) {
          runPostActionHook(resp, args, stores, executionContext);
        }
        cache.results[key] = [true, true, resp, false, Date.now()];
      }
      return resp;
    }).catch((e) => {
      console.error(e);
      const result = {
        payload: null,
        errorPayload: null,
        error: true,
        tags: [EAsyncEndTags.THREW_ERROR],
        message: e.message
      };
      if (currentActionOrd === cache.actionOrd[key]) {
        if (postActionEnabled) {
          runPostActionHook(result, args, stores, executionContext);
        }
        cache.results[key] = [true, true, result, false, Date.now()];
      }
      return result;
    }).then((resp) => {
      if (currentActionOrd === cache.actionOrd[key]) {
        delete cache.actions[key];
        if (!onServer) {
          notifyListeners(key);
        }
      }
      return resp;
    });
  }
  function checkKeyAndReturnResponse({ key, cache, initiate, ssr, args, stores, fromListener = false, postActionEnabled = true, cacheBreakEnabled = true, holdingResult, customContext, customCacheBreak, holdPrevious }) {
    const cached = getCachedResult({
      key,
      cache,
      args,
      stores,
      context: initiate ? EPostActionContext.BECKON_HIT_CACHE : EPostActionContext.WATCH_HIT_CACHE,
      postActionEnabled,
      cacheBreakEnabled,
      fromListener,
      customCacheBreak
    });
    if (cached.response) {
      return cached.response;
    }
    if (!cache.actions.hasOwnProperty(key)) {
      const currentActionOrd = actionOrdUpdate(cache, key);
      if (initiate) {
        if (shortCircuitHook !== void 0) {
          const shortCircuitResponse = shortCircuitHook({ args, stores });
          if (shortCircuitResponse !== false) {
            runPostActionHook(shortCircuitResponse, args, stores, EPostActionContext.SHORT_CIRCUIT);
            cache.results[key] = [true, true, shortCircuitResponse, false, Date.now()];
            return cache.results[key];
          }
        }
        if (ssr || !onServer) {
          cache.actions[key] = createInternalAction(key, cache, args, stores, currentActionOrd, postActionEnabled, EPostActionContext.BECKON_RUN, customContext);
        }
        if (!onServer) {
          cache.actions[key]();
          cache.results[key] = startedButUnfinishedResult;
        } else {
          return startedButUnfinishedResult;
        }
      } else {
        const resp = [
          false,
          false,
          {
            message: "",
            tags: [EAsyncEndTags.UNFINISHED],
            error: true,
            payload: null,
            errorPayload: null
          },
          false,
          -1
        ];
        if (!onServer) {
          cache.results[key] = resp;
        }
        if (holdPrevious) {
          if (holdingResult) {
            const response = [...holdingResult];
            response[3] = true;
            return response;
          }
          if (cached.previous != null) {
            const response = [...cached.previous];
            response[3] = true;
            return response;
          }
        }
        return resp;
      }
    }
    if (holdPrevious) {
      if (holdingResult) {
        const response = [...holdingResult];
        response[3] = true;
        return response;
      }
      if (cached.previous != null) {
        const response = [...cached.previous];
        response[3] = true;
        return response;
      }
    }
    return startedButUnfinishedResult;
  }
  const read = (args = {}, { cacheBreakEnabled = true, postActionEnabled = true, key: customKey } = {}) => {
    const key = _createKey(args, customKey);
    const cache = onServer ? (0, import_react.useContext)(PullstateContext)._asyncCache : clientAsyncCache;
    let stores;
    let customContext;
    if (onServer || forceContext) {
      const pullstateContext = (0, import_react.useContext)(PullstateContext);
      stores = pullstateContext.stores;
      customContext = pullstateContext.customContext;
    } else if (clientStores.loaded) {
      stores = clientStores.stores;
    } else {
      stores = storeErrorProxy;
    }
    const cached = getCachedResult({
      key,
      cache,
      args,
      stores,
      context: EPostActionContext.READ_HIT_CACHE,
      postActionEnabled,
      cacheBreakEnabled,
      fromListener: false
    });
    if (cached.response) {
      if (!cached.response[2].error) {
        return cached.response[2].payload;
      } else {
        throw new PullstateAsyncError(cached.response[2].message, cached.response[2].tags);
      }
    }
    if (!cache.actions.hasOwnProperty(key)) {
      if (shortCircuitHook !== void 0) {
        const shortCircuitResponse = shortCircuitHook({ args, stores });
        if (shortCircuitResponse !== false) {
          runPostActionHook(shortCircuitResponse, args, stores, EPostActionContext.SHORT_CIRCUIT);
          cache.results[key] = [true, true, shortCircuitResponse, false, Date.now()];
          if (!shortCircuitResponse.error) {
            return shortCircuitResponse.payload;
          } else {
            throw new PullstateAsyncError(shortCircuitResponse.message, shortCircuitResponse.tags);
          }
        }
      }
      const currentActionOrd = actionOrdUpdate(cache, key);
      cache.actions[key] = createInternalAction(key, cache, args, stores, currentActionOrd, postActionEnabled, EPostActionContext.READ_RUN, customContext);
      if (onServer) {
        throw new Error(`Pullstate Async Action: action.read() : Resolve all async state for Suspense actions before Server-side render ( make use of instance.runAsyncAction() )`);
      }
      throw cache.actions[key]();
    }
    if (onServer) {
      throw new Error(`Pullstate Async Action: action.read() : Resolve all async state for Suspense actions before Server-side render ( make use of instance.runAsyncAction() )`);
    }
    const watchOrd = watchIdOrd++;
    throw new Promise((resolve) => {
      cache.listeners[key][watchOrd] = () => {
        delete cache.listeners[key][watchOrd];
        resolve();
      };
    });
  };
  const useWatch = (args = {}, { initiate = false, ssr = true, postActionEnabled = false, cacheBreakEnabled = false, holdPrevious = false, dormant = false, key: customKey, cacheBreak: customCacheBreakIncoming } = {}) => {
    const responseRef = (0, import_react.useRef)();
    const prevKeyRef = (0, import_react.useRef)(".");
    const key = dormant ? "." : _createKey(args, customKey);
    let watchId = (0, import_react.useRef)(-1);
    if (watchId.current === -1) {
      watchId.current = watchIdOrd++;
    }
    if (!dormant) {
      if (!shouldUpdate.hasOwnProperty(key)) {
        shouldUpdate[key] = {
          [watchId.current]: true
        };
      } else {
        shouldUpdate[key][watchId.current] = true;
      }
    }
    const cache = onServer ? (0, import_react.useContext)(PullstateContext)._asyncCache : clientAsyncCache;
    let stores;
    let customContext;
    if (onServer || forceContext) {
      const pullstateContext = (0, import_react.useContext)(PullstateContext);
      stores = pullstateContext.stores;
      customContext = pullstateContext.customContext;
    } else if (clientStores.loaded) {
      stores = clientStores.stores;
    } else {
      stores = storeErrorProxy;
    }
    if (!onServer) {
      const onAsyncStateChanged = () => {
        if (shouldUpdate[key][watchId.current] && !(0, import_es6.default)(responseRef.current, cache.results[key])) {
          const nextResponse = checkKeyAndReturnResponse({
            key,
            cache,
            initiate,
            ssr,
            args,
            stores,
            fromListener: true,
            postActionEnabled,
            cacheBreakEnabled,
            holdingResult: void 0,
            customContext,
            holdPrevious
          });
          if (holdPrevious && !nextResponse[1] && responseRef.current != null && responseRef.current[1]) {
            responseRef.current = [...responseRef.current];
            responseRef.current[3] = true;
          } else {
            responseRef.current = nextResponse;
          }
          setWatchUpdate((prev) => {
            return prev + 1;
          });
        }
      };
      if (!dormant) {
        if (!cache.listeners.hasOwnProperty(key)) {
          cache.listeners[key] = {};
        }
        cache.listeners[key][watchId.current] = onAsyncStateChanged;
        shouldUpdate[key][watchId.current] = true;
      }
      (0, import_react.useEffect)(() => {
        if (!dormant) {
          cache.listeners[key][watchId.current] = onAsyncStateChanged;
          shouldUpdate[key][watchId.current] = true;
        }
        return () => {
          if (!dormant) {
            delete cache.listeners[key][watchId.current];
            shouldUpdate[key][watchId.current] = false;
          }
        };
      }, [key]);
    }
    const [_2, setWatchUpdate] = (0, import_react.useState)(0);
    if (dormant) {
      responseRef.current = holdPrevious && responseRef.current && responseRef.current[1] ? responseRef.current : [
        false,
        false,
        {
          message: "",
          tags: [EAsyncEndTags.DORMANT],
          error: true,
          payload: null
        },
        false,
        -1
      ];
      prevKeyRef.current = ".";
    } else if (prevKeyRef.current !== key) {
      if (prevKeyRef.current !== null && shouldUpdate.hasOwnProperty(prevKeyRef.current)) {
        delete cache.listeners[prevKeyRef.current][watchId.current];
        shouldUpdate[prevKeyRef.current][watchId.current] = false;
      }
      prevKeyRef.current = key;
      responseRef.current = checkKeyAndReturnResponse({
        key,
        cache,
        initiate,
        ssr,
        args,
        stores,
        fromListener: false,
        postActionEnabled,
        cacheBreakEnabled,
        holdingResult: holdPrevious && responseRef.current && responseRef.current[1] ? responseRef.current : void 0,
        customContext,
        customCacheBreak: convertCustomCacheBreakHook(customCacheBreakIncoming),
        holdPrevious
      });
    }
    return responseRef.current;
  };
  const useBeckon = (args = {}, { ssr = true, postActionEnabled = true, cacheBreakEnabled = true, holdPrevious = false, dormant = false, key } = {}) => {
    const result = useWatch(args, {
      initiate: true,
      ssr,
      postActionEnabled,
      cacheBreakEnabled,
      holdPrevious,
      dormant,
      key
    });
    return [result[1], result[2], result[3]];
  };
  const run = async (args = {}, inputs = {}) => {
    const { treatAsUpdate = false, ignoreShortCircuit = false, respectCache = false, key: customKey, _asyncCache = clientAsyncCache, _stores = clientStores.loaded ? clientStores.stores : storeErrorProxy, _customContext, cacheBreak: customCacheBreak } = inputs;
    const key = _createKey(args, customKey);
    if (respectCache) {
      const cached = getCachedResult({
        key,
        cache: _asyncCache,
        args,
        stores: _stores,
        context: EPostActionContext.RUN_HIT_CACHE,
        postActionEnabled: true,
        cacheBreakEnabled: true,
        fromListener: false,
        customCacheBreak: convertCustomCacheBreakHook(customCacheBreak)
      });
      if (cached.response && cached.response[0]) {
        if (!cached.response[1]) {
          const watchOrd = watchIdOrd++;
          if (!_asyncCache.listeners.hasOwnProperty(key)) {
            _asyncCache.listeners[key] = {};
          }
          return new Promise((resolve) => {
            _asyncCache.listeners[key][watchOrd] = () => {
              const [, finished, resp] = _asyncCache.results[key];
              if (finished) {
                delete _asyncCache.listeners[key][watchOrd];
                resolve(resp);
              }
            };
          });
        }
        return cached.response[2];
      }
    }
    if (!ignoreShortCircuit && shortCircuitHook !== void 0) {
      const shortCircuitResponse = shortCircuitHook({ args, stores: _stores });
      if (shortCircuitResponse !== false) {
        _asyncCache.results[key] = [true, true, shortCircuitResponse, false, Date.now()];
        runPostActionHook(shortCircuitResponse, args, _stores, EPostActionContext.SHORT_CIRCUIT);
        notifyListeners(key);
        return shortCircuitResponse;
      }
    }
    const [, prevFinished, prevResp, prevUpdate, prevCacheTime] = _asyncCache.results[key] || [
      false,
      false,
      {
        error: true,
        message: "",
        payload: null,
        tags: [EAsyncEndTags.UNFINISHED]
      },
      false,
      -1
    ];
    if (prevFinished && treatAsUpdate) {
      _asyncCache.results[key] = [true, true, prevResp, true, prevCacheTime];
    } else {
      _asyncCache.results[key] = [
        true,
        false,
        {
          error: true,
          message: "",
          payload: null,
          tags: [EAsyncEndTags.UNFINISHED]
        },
        false,
        -1
      ];
    }
    let currentActionOrd = actionOrdUpdate(_asyncCache, key);
    _asyncCache.actions[key] = createInternalAction(key, _asyncCache, args, _stores, currentActionOrd, true, EPostActionContext.DIRECT_RUN, _customContext);
    notifyListeners(key);
    return _asyncCache.actions[key]();
  };
  const clearCache = (args = {}, { key: customKey, notify = true } = {}) => {
    const key = _createKey(args, customKey);
    clearActionCache(key, true, notify);
  };
  const clearAllCache = ({ notify = true } = {}) => {
    for (const key of Object.keys(clientAsyncCache.actionOrd)) {
      if (key.startsWith(`${ordinal}-`)) {
        clearActionCache(key, true, notify);
      }
    }
  };
  const clearAllUnwatchedCache = ({ notify = true } = {}) => {
    for (const key of Object.keys(shouldUpdate)) {
      if (!Object.values(shouldUpdate[key]).some((su) => su)) {
        delete shouldUpdate[key];
        clearActionCache(key, false, notify);
      }
    }
  };
  const setCached = (args, result, options) => {
    const { notify = true, key: customKey } = options || {};
    const key = _createKey(args, customKey);
    const cache = onServer ? (0, import_react.useContext)(PullstateContext)._asyncCache : clientAsyncCache;
    cache.results[key] = [true, true, result, false, Date.now()];
    if (notify) {
      notifyListeners(key);
    }
  };
  const setCachedPayload = (args, payload, options) => {
    return setCached(args, successResult(payload), options);
  };
  const updateCached = (args, updater, options) => {
    const { notify = true, resetTimeCached = true, runPostActionHook: postAction = false, key: customKey } = options || {};
    const key = _createKey(args, customKey);
    const cache = onServer ? (0, import_react.useContext)(PullstateContext)._asyncCache : clientAsyncCache;
    if (cache.results.hasOwnProperty(key) && !cache.results[key][2].error) {
      const currentCached = cache.results[key][2].payload;
      const newResult = {
        payload: immer_esm_default(currentCached, (s2) => updater(s2, currentCached)),
        error: false,
        message: cache.results[key][2].message,
        tags: cache.results[key][2].tags
      };
      if (postAction) {
        runPostActionHook(newResult, args, clientStores.loaded ? clientStores.stores : storeErrorProxy, EPostActionContext.CACHE_UPDATE);
      }
      cache.results[key] = [
        true,
        true,
        newResult,
        cache.results[key][3],
        resetTimeCached ? Date.now() : cache.results[key][4]
      ];
      if (notify) {
        notifyListeners(key);
      }
    }
  };
  const getCached = (args = {}, options) => {
    var _a;
    const { checkCacheBreak = false, key: customKey, cacheBreak: incomingCacheBreak } = options || {};
    const key = _createKey(args, customKey);
    let cacheBreakable = false;
    const cache = clientAsyncCache;
    if (cache.results.hasOwnProperty(key)) {
      const finalizedCacheBreakHook = (_a = convertCustomCacheBreakHook(incomingCacheBreak)) !== null && _a !== void 0 ? _a : cacheBreakHook;
      if (checkCacheBreak && finalizedCacheBreakHook !== void 0) {
        const stores = onServer ? (0, import_react.useContext)(PullstateContext).stores : clientStores.loaded ? clientStores.stores : storeErrorProxy;
        if (finalizedCacheBreakHook({
          args,
          result: cache.results[key][2],
          stores,
          timeCached: cache.results[key][4]
        })) {
          cacheBreakable = true;
        }
      }
      const [started, finished, result, updating, timeCached] = cache.results[key];
      return {
        started,
        finished,
        result,
        existed: true,
        cacheBreakable,
        updating,
        timeCached
      };
    } else {
      return {
        started: false,
        finished: false,
        result: {
          message: "",
          tags: [EAsyncEndTags.UNFINISHED],
          error: true,
          payload: null,
          errorPayload: null
        },
        updating: false,
        existed: false,
        cacheBreakable,
        timeCached: -1
      };
    }
  };
  let delayedRunActionTimeout;
  const delayedRun = (args = {}, { clearOldRun = true, delay, immediateIfCached = true, ...otherRunOptions }) => {
    if (clearOldRun) {
      clearTimeout(delayedRunActionTimeout);
    }
    if (immediateIfCached) {
      const { finished, cacheBreakable } = getCached(args, { checkCacheBreak: true });
      if (finished && !cacheBreakable) {
        run(args, otherRunOptions);
        return () => {
        };
      }
    }
    let ref = { cancelled: false };
    delayedRunActionTimeout = setTimeout(() => {
      if (!ref.cancelled) {
        run(args, otherRunOptions);
      }
    }, delay);
    return () => {
      ref.cancelled = true;
    };
  };
  const use = (args = {}, { initiate = true, ssr = true, postActionEnabled, cacheBreakEnabled, holdPrevious = false, dormant = false, key, onSuccess, cacheBreak: customCacheBreakHook } = {}) => {
    if (postActionEnabled == null) {
      postActionEnabled = initiate;
    }
    if (cacheBreakEnabled == null) {
      cacheBreakEnabled = initiate;
    }
    const raw = useWatch(args, {
      initiate,
      ssr,
      postActionEnabled,
      cacheBreakEnabled,
      holdPrevious,
      dormant,
      key,
      cacheBreak: customCacheBreakHook
    });
    const [isStarted, isFinished, result, isUpdating] = raw;
    const isSuccess = isFinished && !result.error;
    const isFailure = isFinished && result.error;
    if (onSuccess) {
      (0, import_react.useEffect)(() => {
        if (isSuccess && !dormant) {
          onSuccess(result.payload, args);
        }
      }, [isSuccess]);
    }
    const renderPayload = (func) => {
      if (!result.error) {
        return func(result.payload);
      }
      return import_react.default.Fragment;
    };
    return {
      isStarted,
      isFinished,
      isUpdating,
      isSuccess,
      isFailure,
      isLoading: isStarted && (!isFinished || isUpdating),
      endTags: result.tags,
      error: result.error,
      payload: result.payload,
      errorPayload: result.errorPayload,
      renderPayload,
      message: result.message,
      raw,
      execute: (runOptions) => run(args, runOptions),
      clearCached: () => clearCache(args),
      setCached: (response, options) => {
        setCached(args, response, options);
      },
      setCachedPayload: (payload, options) => {
        setCachedPayload(args, payload, options);
      },
      updateCached: (updater, options) => {
        updateCached(args, updater, options);
      }
    };
  };
  const useDefer = (inputs = {}) => {
    const [argState, setArgState] = (0, import_react.useState)(() => ({
      key: inputs.key ? inputs.key : deferWaitingKey,
      args: {}
    }));
    const initialResponse = use({}, {
      ...inputs,
      key: argState.key,
      initiate: false
    });
    const hasCached = (args = {}, options = {}) => {
      var _a, _b;
      const executionKey = (_a = inputs.key) !== null && _a !== void 0 ? _a : _createKey(args);
      const { checkCacheBreak = true, successOnly = false } = options;
      const cached = getCached(args, {
        key: executionKey,
        cacheBreak: (_b = options.cacheBreak) !== null && _b !== void 0 ? _b : inputs.cacheBreak,
        checkCacheBreak
      });
      if (cached.existed) {
        if (!checkCacheBreak || !cached.cacheBreakable) {
          return !successOnly || !cached.result.error;
        }
      }
      return false;
    };
    const unwatchExecuted = () => {
      setArgState({ key: deferWaitingKey, args: {} });
    };
    const execute = (args = {}, runOptions) => {
      var _a;
      const executionKey = (_a = inputs.key) !== null && _a !== void 0 ? _a : _createKey(args);
      if (executionKey !== argState.key) {
        setArgState({ key: executionKey, args });
      }
      return run(args, {
        ...runOptions,
        key: executionKey,
        cacheBreak: inputs.cacheBreak
      }).then((resp) => {
        if (inputs.clearOnSuccess) {
          clearCache({}, { key: executionKey });
        }
        return resp;
      });
    };
    return {
      ...initialResponse,
      clearCached: () => {
        clearCache({}, { key: argState.key });
      },
      unwatchExecuted,
      setCached: (response, options = {}) => {
        options.key = argState.key;
        setCached({}, response, options);
      },
      setCachedPayload: (payload, options = {}) => {
        options.key = argState.key;
        setCachedPayload({}, payload, options);
      },
      updateCached: (updater, options = {}) => {
        options.key = argState.key;
        updateCached({}, updater, options);
      },
      useDebouncedExecution: (args, delay, options = {}) => {
        if (!onServer) {
          const stateRef = (0, import_react.useRef)({ update: false });
          const currentValue = (0, import_react.useRef)(void 0);
          const executionOrd = (0, import_react.useRef)(-1);
          const timeout = (0, import_react.useRef)(void 0);
          (0, import_react.useEffect)(() => {
            stateRef.current.update = true;
            return () => {
              stateRef.current.update = false;
            };
          }, []);
          const hasEqualityCheck = options.equality != null;
          if (hasEqualityCheck) {
            if (typeof options.equality === "function") {
              if (currentValue.current === void 0 || options.equality(currentValue.current, args)) {
                currentValue.current = args;
                executionOrd.current += 1;
              }
            } else if (currentValue.current !== options.equality) {
              currentValue.current = options.equality;
              executionOrd.current += 1;
            }
          } else if (!(0, import_es6.default)(currentValue.current, args)) {
            currentValue.current = args;
            executionOrd.current += 1;
          }
          (0, import_react.useEffect)(() => {
            var _a, _b, _c;
            clearTimeout(timeout.current);
            const executeAction = () => {
              var _a2;
              if (stateRef.current.update) {
                execute(args, (_a2 = options.executeOptions) !== null && _a2 !== void 0 ? _a2 : { respectCache: true });
              }
            };
            if ((_b = (_a = options.validInput) === null || _a === void 0 ? void 0 : _a.call(options, args)) !== null && _b !== void 0 ? _b : true) {
              if (hasCached(args)) {
                executeAction();
              } else {
                timeout.current = setTimeout(executeAction, delay);
              }
            } else if (!((_c = options.watchLastValid) !== null && _c !== void 0 ? _c : false)) {
              unwatchExecuted();
            }
          }, [executionOrd.current]);
        }
      },
      hasCached,
      execute,
      args: argState.args,
      key: argState.key
    };
  };
  return {
    use,
    useDefer,
    read,
    useBeckon,
    useWatch,
    run,
    delayedRun,
    clearCache,
    clearAllCache,
    clearAllUnwatchedCache,
    getCached,
    setCached,
    setCachedPayload,
    updateCached
  };
}
var PullstateContext = import_react.default.createContext(null);
var PullstateProvider = ({ instance, children }) => {
  return import_react.default.createElement(PullstateContext.Provider, { value: instance }, children);
};
var singleton = null;
var clientStores = {
  internalClientStores: true,
  loaded: false,
  stores: {}
};
var PullstateSingleton = class {
  constructor(allStores, options = {}) {
    this.options = {};
    if (singleton !== null) {
      console.error(`Pullstate: createPullstate() - Should not be creating the core Pullstate class more than once! In order to re-use pull state, you need to call instantiate() on your already created object.`);
    }
    singleton = this;
    clientStores.stores = allStores;
    clientStores.loaded = true;
    this.options = options;
  }
  instantiate({ hydrateSnapshot, ssr = false, customContext } = {}) {
    if (!ssr) {
      const instantiated = new PullstateInstance(clientStores.stores, false, customContext);
      if (hydrateSnapshot != null) {
        instantiated.hydrateFromSnapshot(hydrateSnapshot);
      }
      instantiated.instantiateReactions();
      return instantiated;
    }
    const newStores = {};
    for (const storeName of Object.keys(clientStores.stores)) {
      if (hydrateSnapshot == null) {
        newStores[storeName] = new Store(clientStores.stores[storeName]._getInitialState());
      } else if (hydrateSnapshot.hasOwnProperty(storeName)) {
        newStores[storeName] = new Store(hydrateSnapshot.allState[storeName]);
      } else {
        newStores[storeName] = new Store(clientStores.stores[storeName]._getInitialState());
        console.warn(`Pullstate (instantiate): store [${storeName}] didn't hydrate any state (data was non-existent on hydration object)`);
      }
      newStores[storeName]._setInternalOptions({
        ssr,
        reactionCreators: clientStores.stores[storeName]._getReactionCreators()
      });
    }
    return new PullstateInstance(newStores, true, customContext);
  }
  useStores() {
    return useStores();
  }
  useInstance() {
    return useInstance();
  }
  createAsyncActionDirect(action, options = {}) {
    return createAsyncActionDirect(action, options);
  }
  createAsyncAction(action, options = {}) {
    var _a;
    if (((_a = this.options.asyncActions) === null || _a === void 0 ? void 0 : _a.defaultCachingSeconds) && !options.cacheBreakHook) {
      options.cacheBreakHook = (inputs) => inputs.timeCached < Date.now() - this.options.asyncActions.defaultCachingSeconds * 1e3;
    }
    return createAsyncAction(action, options);
  }
};
var PullstateInstance = class {
  constructor(allStores, ssr, customContext) {
    this._ssr = false;
    this._stores = {};
    this._asyncCache = {
      listeners: {},
      results: {},
      actions: {},
      actionOrd: {}
    };
    this._stores = allStores;
    this._ssr = ssr;
    this._customContext = customContext;
  }
  getAllUnresolvedAsyncActions() {
    return Object.keys(this._asyncCache.actions).map((key) => this._asyncCache.actions[key]());
  }
  instantiateReactions() {
    for (const storeName of Object.keys(this._stores)) {
      this._stores[storeName]._instantiateReactions();
    }
  }
  getPullstateSnapshot() {
    const allState = {};
    for (const storeName of Object.keys(this._stores)) {
      allState[storeName] = this._stores[storeName].getRawState();
    }
    return { allState, asyncResults: this._asyncCache.results, asyncActionOrd: this._asyncCache.actionOrd };
  }
  async resolveAsyncState() {
    const promises = this.getAllUnresolvedAsyncActions();
    await Promise.all(promises);
  }
  hasAsyncStateToResolve() {
    return Object.keys(this._asyncCache.actions).length > 0;
  }
  get stores() {
    return this._stores;
  }
  get customContext() {
    return this._customContext;
  }
  async runAsyncAction(asyncAction, args = {}, runOptions = {}) {
    if (this._ssr) {
      runOptions._asyncCache = this._asyncCache;
      runOptions._stores = this._stores;
      runOptions._customContext = this._customContext;
    }
    return await asyncAction.run(args, runOptions);
  }
  hydrateFromSnapshot(snapshot) {
    for (const storeName of Object.keys(this._stores)) {
      if (snapshot.allState.hasOwnProperty(storeName)) {
        this._stores[storeName]._updateStateWithoutReaction(snapshot.allState[storeName]);
      } else {
        console.warn(`${storeName} didn't hydrate any state (data was non-existent on hydration object)`);
      }
    }
    clientAsyncCache.results = snapshot.asyncResults || {};
    clientAsyncCache.actionOrd = snapshot.asyncActionOrd || {};
  }
};
function createPullstateCore(allStores = {}, options = {}) {
  return new PullstateSingleton(allStores, options);
}
function useStores() {
  return (0, import_react.useContext)(PullstateContext).stores;
}
function useInstance() {
  return (0, import_react.useContext)(PullstateContext);
}
var EAsyncActionInjectType;
(function(EAsyncActionInjectType2) {
  EAsyncActionInjectType2["WATCH"] = "watch";
  EAsyncActionInjectType2["BECKON"] = "beckon";
})(EAsyncActionInjectType || (EAsyncActionInjectType = {}));
function InjectAsyncAction(props) {
  if (props.type === EAsyncActionInjectType.BECKON) {
    const response2 = props.action.useBeckon(props.args, props.options);
    return props.children(response2);
  }
  const response = props.action.useWatch(props.args, props.options);
  return props.children(response);
}
function InjectStoreStateOpt({ store, paths, children }) {
  const state = useStoreStateOpt(store, paths);
  return children(state);
}
function registerInDevtools(stores, { namespace = "" } = {}) {
  var _a;
  const devToolsExtension = typeof window !== "undefined" ? (_a = window) === null || _a === void 0 ? void 0 : _a.__REDUX_DEVTOOLS_EXTENSION__ : void 0;
  if (devToolsExtension) {
    for (const key of Object.keys(stores)) {
      const store = stores[key];
      const devTools = devToolsExtension.connect({ name: `${namespace}${key}` });
      devTools.init(store.getRawState());
      let ignoreNext = false;
      store.subscribe((s2) => s2, (watched) => {
        if (ignoreNext) {
          ignoreNext = false;
          return;
        }
        devTools.send("Change", watched);
      });
      devTools.subscribe((message) => {
        if (message.type === "DISPATCH" && message.state) {
          ignoreNext = true;
          const parsed = JSON.parse(message.state);
          store.replace(parsed);
        }
      });
    }
  }
}
var batchState = {};
function setupBatch({ uiBatchFunction }) {
  batchState.uiBatchFunction = uiBatchFunction;
}
function batch(runUpdates2) {
  if (globalClientState.batching) {
    throw new Error("Pullstate: Can't enact two batch() update functions at the same time-\nmake sure you are not running a batch() inside of a batch() by mistake.");
  }
  globalClientState.batching = true;
  try {
    runUpdates2();
  } finally {
    if (batchState.uiBatchFunction) {
      batchState.uiBatchFunction(() => {
        Object.values(globalClientState.flushStores).forEach((store) => store.flushBatch(true));
      });
    } else {
      Object.values(globalClientState.flushStores).forEach((store) => store.flushBatch(true));
    }
    globalClientState.flushStores = {};
    globalClientState.batching = false;
  }
}
export {
  EAsyncActionInjectType,
  EAsyncEndTags,
  EPostActionContext,
  InjectAsyncAction,
  InjectStoreState,
  InjectStoreStateOpt,
  PullstateContext,
  PullstateProvider,
  Store,
  batch,
  createAsyncAction,
  createAsyncActionDirect,
  createPullstateCore,
  errorResult,
  registerInDevtools,
  setupBatch,
  successResult,
  update,
  useInstance,
  useLocalStore,
  useStoreState,
  useStoreStateOpt,
  useStores
};
//# sourceMappingURL=pullstate.js.map
